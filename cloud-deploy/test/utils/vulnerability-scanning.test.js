import * as exec from '@actions/exec';
import fs from 'fs';
import { afterEach, describe, expect, test, vi } from 'vitest';

import slackNotify from '../../../slack-notify/src/slack-notify.js';
import { saveVulnerabilities } from '../../src/utils/send-request.js';
import runScan from '../../src/utils/vulnerability-scanning.js';
vi.mock('@actions/exec');
vi.mock('@actions/core');
vi.mock('../../../slack-notify/src/slack-notify.js');
vi.mock('../../src/utils/send-request.js');
vi.mock('fs');

const result = `eu.gcr.io/extenda/iam-das-sync-worker:v0.3.2 (debian 9.13)
==========================================================
Total: 2 (UNKNOWN: 0, LOW: 1, MEDIUM: 0, HIGH: 2, CRITICAL: 1)

usr/src/app/package-lock.json
=============================
Total: 3 (UNKNOWN: 0, LOW: 0, MEDIUM: 2, HIGH: 1, CRITICAL: 0)`;

describe('Run scan and notify on slack', () => {
  afterEach(() => {
    vi.resetAllMocks();
  });

  test('Can run scan without issues', async () => {
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    await runScan('service-account', 'ubuntu');
    expect(exec.exec).toHaveBeenCalledTimes(3);
  });

  test('Can run scan even when slackNotify fails', async () => {
    slackNotify.mockRejectedValueOnce(
      new Error("Couldn't fetch slack secrets!"),
    );
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    vi.spyOn(fs, 'readFileSync').mockReturnValueOnce(result);
    await expect(
      runScan('service-account', 'ubuntu', 'service'),
    ).resolves.not.toThrow();
    expect(slackNotify).toHaveBeenCalledTimes(1);
    expect(slackNotify).toHaveBeenCalledWith(
      'service-account',
      'Total vulnerabilities found on ubuntu: 5\n' +
        '  High: 3\n' +
        '  Critical: 1\n' +
        '  ',
      '',
      'service-scanReport.txt',
    );
    expect(exec.exec).toHaveBeenCalledTimes(3);
  });

  test('Build report correctly', async () => {
    // install mock
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    // read file in image scan
    vi.spyOn(fs, 'readFileSync').mockReturnValueOnce(result);

    await runScan('service-account', 'ubuntu', 'service');
    expect(slackNotify).toHaveBeenCalledTimes(1);
    expect(slackNotify).toHaveBeenCalledWith(
      'service-account',
      'Total vulnerabilities found on ubuntu: 5\n' +
        '  High: 3\n' +
        '  Critical: 1\n' +
        '  ',
      '',
      'service-scanReport.txt',
    );
    expect(exec.exec).toHaveBeenCalledTimes(3);
  });

  test('Send vulnerabilities', async () => {
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    saveVulnerabilities.mockResolvedValueOnce('success');
    vi.spyOn(fs, 'readFileSync').mockReturnValueOnce(result);
    await runScan('service-account', 'ubuntu', 'service', 'labels');

    expect(saveVulnerabilities).toHaveBeenCalledTimes(1);
    expect(exec.exec).toHaveBeenCalledTimes(3);
  });

  test('writes compact report for normal scan data', async () => {
    const scanJson = JSON.stringify({
      Results: [
        {
          Vulnerabilities: [
            {
              Severity: 'HIGH',
              VulnerabilityID: 'CVE-2025-9900',
              PkgName: 'libtiff-dev',
              Title: 'libtiff: Libtiff Write-What-Where',
            },
            {
              Severity: 'CRITICAL',
              VulnerabilityID: 'CVE-2025-9999',
              PkgName: 'openssl',
              Title: 'openssl: Buffer overflow',
            },
            {
              Severity: 'MEDIUM',
              VulnerabilityID: 'CVE-2025-8888',
              PkgName: 'curl',
              Title: 'curl: Some medium issue',
            },
            {
              Severity: 'LOW',
              VulnerabilityID: 'CVE-2025-7777',
              PkgName: 'zlib',
              Title: 'zlib: Some low issue',
            },
            {
              Severity: 'UNKNOWN',
              VulnerabilityID: 'CVE-2025-6666',
              PkgName: 'foo',
              Title: 'foo: Unknown issue',
            },
          ],
        },
      ],
    });
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    vi.spyOn(fs, 'existsSync').mockReturnValue(true);
    fs.readFileSync.mockReturnValue(scanJson);
    vi.spyOn(fs, 'writeFileSync').mockImplementation(() => {});
    await runScan('svc', 'img:v1', 'svc');
    expect(fs.writeFileSync).toHaveBeenCalledWith(
      'svc-scanReport.txt',
      expect.stringContaining('Service: svc'),
      'utf8',
    );
    expect(fs.writeFileSync).toHaveBeenCalledWith(
      'svc-scanReport.txt',
      expect.stringContaining('HIGH'),
      'utf8',
    );
    expect(fs.writeFileSync).toHaveBeenCalledWith(
      'svc-scanReport.txt',
      expect.stringContaining('CRITICAL'),
      'utf8',
    );
  });

  test('writes compact report for empty scan data', async () => {
    const scanJson = JSON.stringify({ Results: [] });
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    vi.spyOn(fs, 'existsSync').mockReturnValue(true);
    fs.readFileSync.mockReturnValue(scanJson);
    vi.spyOn(fs, 'writeFileSync').mockImplementation(() => {});
    await runScan('svc', 'img:v1', 'svc');
    expect(fs.writeFileSync).toHaveBeenCalledWith(
      'svc-scanReport.txt',
      expect.stringContaining('No vulnerabilities found'),
      'utf8',
    );
  });

  test('does not write report if scanReport.json missing', async () => {
    exec.exec.mockResolvedValueOnce('download trivy completed');
    exec.exec.mockResolvedValueOnce('trivy install completed');
    exec.exec.mockResolvedValueOnce('scan completed');
    exec.exec.mockResolvedValueOnce('convertion completed');
    vi.spyOn(fs, 'existsSync').mockReturnValue(false);
    vi.spyOn(fs, 'writeFileSync').mockImplementation(() => {});
    await runScan('svc', 'img:v1', 'svc');
    expect(fs.writeFileSync).not.toHaveBeenCalled();
  });
});

describe('convertToReportCompact severity ordering', () => {
  afterEach(() => {
    vi.resetAllMocks();
  });

  test('orders vulnerabilities by severity', async () => {
    const scanJson = JSON.stringify({
      Results: [
        {
          Vulnerabilities: [
            {
              Severity: 'LOW',
              VulnerabilityID: 'CVE-LOW',
              PkgName: 'pkg1',
              Title: 'Low vuln',
            },
            {
              Severity: 'CRITICAL',
              VulnerabilityID: 'CVE-CRIT',
              PkgName: 'pkg2',
              Title: 'Critical vuln',
            },
            {
              Severity: 'HIGH',
              VulnerabilityID: 'CVE-HIGH',
              PkgName: 'pkg3',
              Title: 'High vuln',
            },
            {
              Severity: 'MEDIUM',
              VulnerabilityID: 'CVE-MED',
              PkgName: 'pkg4',
              Title: 'Medium vuln',
            },
            {
              Severity: 'UNKNOWN',
              VulnerabilityID: 'CVE-UNK',
              PkgName: 'pkg5',
              Title: 'Unknown vuln',
            },
          ],
        },
      ],
    });
    const expectedOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'UNKNOWN'];
    exec.exec.mockResolvedValue('ok');
    fs.existsSync.mockReturnValue(true);
    fs.readFileSync.mockReturnValue(scanJson);
    let written = '';
    fs.writeFileSync.mockImplementation((file, content) => {
      written = content;
    });
    await runScan('svc', 'img:v1', 'svc');
    const lines = written
      .split('\n')
      .filter((l) => l.match(/CRITICAL|HIGH|MEDIUM|LOW|UNKNOWN/));
    const foundOrder = lines
      .slice(1)
      .map((l) => l.match(/CRITICAL|HIGH|MEDIUM|LOW|UNKNOWN/)[0]);
    expect(foundOrder).toEqual(expectedOrder);
  });
});
