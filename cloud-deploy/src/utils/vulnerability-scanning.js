const exec = require('@actions/exec');
const core = require('@actions/core');
const notifySlack = require('../../../slack-notify/src/slack-notify');
const fs = require('fs');
const { saveVulnerabilities } = require('./send-request');

const convertToReportCompact = async (serviceName, image) => {
  const file = 'scanReport.json';
  if (!fs.existsSync(file)) {
    return 'File not found';
  }
  const data = JSON.parse(fs.readFileSync(file, 'utf8'));
  let rows = [];
  if (Array.isArray(data.Results)) {
    for (const result of data.Results) {
      if (Array.isArray(result.Vulnerabilities)) {
        for (const vuln of result.Vulnerabilities) {
          rows.push({
            Severity: vuln.Severity || '',
            ID: vuln.VulnerabilityID || '',
            Pkg: vuln.PkgName || '',
            Title: vuln.Title ? vuln.Title.replace(/\n/g, ' ') : '',
          });
        }
      }
    }
  }

  const severityOrder = { CRITICAL: 1, HIGH: 2, MEDIUM: 3, LOW: 4, UNKNOWN: 5 };
  rows.sort(
    (a, b) =>
      (severityOrder[a.Severity] || 6) - (severityOrder[b.Severity] || 6),
  );
  let total = 0,
    unknown = 0,
    low = 0,
    medium = 0,
    high = 0,
    critical = 0;
  for (const row of rows) {
    total++;
    switch (row.Severity) {
      case 'UNKNOWN':
        unknown++;
        break;
      case 'LOW':
        low++;
        break;
      case 'MEDIUM':
        medium++;
        break;
      case 'HIGH':
        high++;
        break;
      case 'CRITICAL':
        critical++;
        break;
    }
  }
  const totalsLine = `Service: ${serviceName}\nImage: ${image}\nTotal: ${total} (UNKNOWN: ${unknown}, LOW: ${low}, MEDIUM: ${medium}, HIGH: ${high}, CRITICAL: ${critical})\n`;
  const headers = ['Severity', 'Vulnerability', 'Package', 'Title'];
  const maxColWidths = {
    Severity: 10,
    Vulnerability: 20,
    Package: 30,
    Title: 64,
  };

  const pad = (str, len) => {
    let s = str || '';
    if (s.length > len) s = s.slice(0, len - 3) + '...';
    return s.padEnd(len, ' ');
  };

  let table = headers.map((h) => pad(h, maxColWidths[h])).join(' ') + '\n';
  table += headers.map((h) => '-'.repeat(maxColWidths[h])).join(' ') + '\n';

  for (const row of rows) {
    table +=
      pad(row.Severity, maxColWidths.Severity) +
      ' ' +
      pad(row.ID, maxColWidths.Vulnerability) +
      ' ' +
      pad(row.Pkg, maxColWidths.Package) +
      ' ' +
      pad(row.Title, maxColWidths.Title) +
      '\n';
  }

  if (rows.length === 0) {
    table +=
      pad(
        '_No vulnerabilities found_',
        maxColWidths.Severity +
          maxColWidths.Vulnerability +
          maxColWidths.Package +
          maxColWidths.Title,
      ) + '\n';
  }

  const slackTable = totalsLine + table;
  fs.writeFileSync(`${serviceName}-scanReport.txt`, slackTable, 'utf8');
  return slackTable;
};

const runImageScan = async (image, serviceName, silent = true) => {
  let output = '';
  await exec
    .exec(
      'trivy',
      [
        'image',
        image,
        '--timeout=900s',
        '-o',
        'scanReport.json',
        '--db-repository=ghcr.io/aquasecurity/trivy-db:2,public.ecr.aws/aquasecurity/trivy-db',
        '--format=json',
        '--severity=CRITICAL,HIGH',
        '--ignore-unfixed',
      ],
      {
        silent,
        listeners: {
          stdout: (data) => {
            output += data.toString('utf8');
          },
        },
      },
    )
    .then(() => convertToReportCompact(serviceName, image));
  return output;
};

const buildReport = async (scanReport, image) => {
  let results = [];
  const totResults = [0, 0, 0, 0, 0, 0];
  const scanResults = scanReport.split(/\r?\n/);
  for (let i = 0; i < scanResults.length; i += 1) {
    const line = scanResults[i];
    if (line.startsWith('Total:')) {
      results = line.match(
        /Total: ([0-9]+) \(UNKNOWN: ([0-9]+), LOW: ([0-9]+), MEDIUM: ([0-9]+), HIGH: ([0-9]+), CRITICAL: ([0-9]+)\)/,
      );
      totResults[0] += parseInt(results[1], 10);
      totResults[1] += parseInt(results[2], 10);
      totResults[2] += parseInt(results[3], 10);
      totResults[3] += parseInt(results[4], 10);
      totResults[4] += parseInt(results[5], 10);
      totResults[5] += parseInt(results[6], 10);
    }
  }

  return {
    MESSAGE: `Total vulnerabilities found on ${image}: ${totResults[0]}
  High: ${totResults[4]}
  Critical: ${totResults[5]}
  `,
    HIGH: totResults[4],
    CRITICAL: totResults[5],
    scanReport,
  };
};

const installTrivy = async () => {
  process.env.TRIVY_DISABLE_VEX_NOTICE = 'DISABLED';
  await exec.exec(
    'wget',
    [
      'https://github.com/aquasecurity/trivy/releases/download/v0.58.0/trivy_0.58.0_Linux-64bit.deb',
    ],
    {
      silent: true,
    },
  );
  await exec.exec('sudo dpkg', ['-i', 'trivy_0.58.0_Linux-64bit.deb'], {
    silent: true,
  });
};

const scanImage = async (image, serviceName) => {
  return await runImageScan(image, serviceName).then(() =>
    buildReport(
      fs.readFileSync(`${serviceName}-scanReport.txt`, 'utf-8'),
      image,
    )
      .then((report) => {
        core.info(report.MESSAGE);
        core.startGroup('full vulnerability scan report');
        core.info(report.scanReport);
        core.endGroup();
        return report;
      })
      .catch(() => core.error('no report generated')),
  );
};

const notify = async (serviceAccount, serviceName, report, labels) => {
  if (report && report.CRITICAL > 0) {
    core.info('Sending slack notification');
    await notifySlack(
      serviceAccount,
      report.MESSAGE,
      '',
      `${serviceName}-scanReport.txt`,
    );
  }
  return await saveVulnerabilities(
    serviceName,
    fs.readFileSync('scanReport.json', 'utf-8'),
    labels,
    `https://github.com/${process.env.GITHUB_REPOSITORY}`,
  );
};

const runScan = async (serviceAccount, image, serviceName, labels) =>
  installTrivy()
    .then(() =>
      scanImage(image, serviceName).then((report) =>
        notify(serviceAccount, serviceName, report, labels).catch((error) =>
          core.error(error),
        ),
      ),
    )
    .catch((err) => core.error(err));

module.exports = runScan;
